Description: Video analytics via. TwelveLabs APIs

Parameters:
  TwelveLabAPIKey:
    Type: String
    Description: API key for TwelveLabs.

  TwelveLabIndexId:
    Type: String
    Description: Index ID from TwelveLabs.

Resources:
  #
  # S3 Bucket
  #
  S3:
    Type: AWS::S3::Bucket
    Properties:
      NotificationConfiguration:
        LambdaConfigurations:
          - Event: s3:ObjectCreated:Put
            Filter:
              S3Key:
                Rules:
                  - Name: prefix
                    Value: milk/
                  - Name: suffix
                    Value: .mp4
            Function: !GetAtt SimpleChecksIndexingLambda.Arn
    DependsOn:
      - SimpleChecksIndexingLambda
      - S3InvokeLambdaPermission

  #
  # DyanmoDB Tables
  #
  SimpleChecksIndexing:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: simple_checks_indexing
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: s3_path
          AttributeType: S # string attribute
      KeySchema:
        - AttributeName: s3_path
          KeyType: HASH # partition key
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
  
  IsPartofCampaign:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: is_part_of_campaign
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: s3_path
          AttributeType: S # string attribute
      KeySchema:
        - AttributeName: s3_path
          KeyType: HASH # partition key
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
            
  MilkMob:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: milk_mob
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: s3_path
          AttributeType: S # string attribute
      KeySchema:
        - AttributeName: s3_path
          KeyType: HASH # partition key
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES

  #
  # S3 Vector
  #
  S3Vector:
    Type: AWS::S3Vectors::VectorBucket
    Properties:
      VectorBucketName: got-milk

  S3Index:
    Type: AWS::S3Vectors::Index
    Properties:
      IndexName: visual-video
      DataType: float32
      Dimension: 512     
      DistanceMetric: cosine
      VectorBucketArn: !GetAtt S3Vector.VectorBucketArn

  #
  # Lambda Function IAM role
  #
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: "sts:AssumeRole"
      Policies:
        # Imporvement required - premissions need to be scoped down
        - PolicyName: Admin
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: 
                  - '*'
                Resource: '*'

  #
  # Lambda Layer w/ Twelve Labs Libraries
  #
  TwelveLabLambdaLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: twelvelabs-layer
      CompatibleArchitectures: 
        - 'x86_64'
      CompatibleRuntimes: 
        - 'python3.14'
      Content: 
        S3Bucket: 'sharkech-public'
        S3Key: 'misc-public/twelvelabs-layer.zip'
      LicenseInfo: String
                
  #
  # Lambda Function #1 - simple_checks_indexing
  #
  SimpleChecksIndexingLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: simple_checks_indexing
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.14
      Code:
        ZipFile: |
          import json
          import urllib.parse
          import boto3
          import os

          from twelvelabs import TwelveLabs 
          from twelvelabs.tasks import TasksRetrieveResponse
          
          def lambda_handler(event, context):
            s3 = boto3.client("s3")
            dynamodb = boto3.resource("dynamodb")

            print("=== FULL S3 EVENT ===")
            print(json.dumps(event))

            # Process all S3 records (in case multiple files are uploaded at once)
            for record in event.get("Records", []):
                bucket = record["s3"]["bucket"]["name"]
                key = urllib.parse.unquote_plus(record["s3"]["object"]["key"])
        
                print(f"Bucket: {bucket}")
                print(f"Key: {key}")
        
                print("=== Check metadata (json file) ===")
                json_key = key.rsplit('.', 1)[0] + ".json"   # replace .mp4 with .json
        
                print(f"Looking for JSON metadata file: {json_key}")
                    
                json_obj = s3.get_object(Bucket=bucket, Key=json_key)
                json_data = json_obj['Body'].read().decode('utf-8')
                metadata = json.loads(json_data)
        
                print("=== JSON Metadata ===")
                print(json.dumps(metadata))
        
                # Check for required tags
                tags = metadata.get("tags", [])
                tags_lower = [t.lower() for t in tags]
                has_tag = ("#gotmilk?" in tags_lower) or ("#milkmob" in tags_lower)
                
                if not has_tag:
                    print(f"Skipping {key}: missing required tag")
                    continue
        
                # Check for excluded accounts
                account = metadata.get("account", "")
                excluded_accounts = ["BadAccount1", "BadAccount2"]
        
                if account in excluded_accounts:
                    print(f"Skipping {key}: excluded account {account}")
                    continue
        
                print("=== GET S3 PRESIGNED URL ===")
                # Generate 15-minute presigned URL
                url = s3.generate_presigned_url(
                    ClientMethod="get_object",
                    Params={"Bucket": bucket, "Key": key},
                    ExpiresIn=900  # 900 seconds = 15 minutes
                )
        
                print("Generated Presigned URL:")
                print(url)
        
                print("=== INDEXING ===")
                # Initialize the clien
                client = TwelveLabs(api_key=os.environ["API_KEY"])
        
                # Upload a video
                task = client.tasks.create(
                    index_id=os.environ["INDEX_ID"],
                    video_url=url
                )
                print(f"Created task: id={task.id}")
            
                # Monitor the indexing process
                def on_task_update(task: TasksRetrieveResponse):
                    print(f"Status={task.status}")
        
                task = client.tasks.wait_for_done(task_id=task.id, callback=on_task_update)
        
                if task.status != "ready":
                    raise RuntimeError(f"Indexing failed with status {task.status}")
            
                print(f"Upload complete. The unique identifier of your video is {task.video_id}.")
            
                print("=== WRITE TO DYNAMODB ===")
                table = dynamodb.Table("simple_checks_indexing")
            
                item = {
                    "s3_path": key,
                    "video_id": task.video_id,
                    "index_id": os.environ["INDEX_ID"],
                    "bucket": bucket,                 
                    "metadata": metadata,
                    "s3_prefix": key
                }
        
                table.put_item(Item=item)
                print("Wrote item to DynamoDB")
  
            # Return lambda response
            return {
              'statusCode': 200,
                'body': json.dumps('Lambda execution complete')
            }          
      Timeout: 300
      MemorySize: 1024
      EphemeralStorage: 
        Size: 1024
      Layers:
        - !Ref TwelveLabLambdaLayer
      Environment:
        Variables:
          API_KEY: !Ref TwelveLabAPIKey
          INDEX_ID: !Ref TwelveLabIndexId

  # S3 premisions for the Lambda event trigger
  S3InvokeLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt SimpleChecksIndexingLambda.Arn
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
  
  #
  # Lambda Function #2 - is_part_of_campaign 
  #
  IsPartOfCampaign:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: is_part_of_campaign 
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.14
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          from twelvelabs import TwelveLabs 
          
          def lambda_handler(event, context):
            dynamodb = boto3.resource("dynamodb")

            print("=== FULL DynamoDB EVENT ===")
            print(json.dumps(event))
        
            client = TwelveLabs(api_key=os.environ["API_KEY"])
        
            for record in event.get("Records", []):
        
                # Skip anything that is NOT an INSERT
                if record["eventName"] != "INSERT":
                    print(f"Skipping event {record['eventName']}")
                    continue
        
                video_id = record["dynamodb"]["NewImage"]["video_id"]["S"]
        
                print("Processing INSERT for video_id:", video_id)
        
                yes_count = 0
        
                print("=== Is drinking milk depicted in the video? ===")
                res1 = client.analyze(
                    video_id=video_id,
                    prompt="Is drinking milk depicted in the video? Answer Yes or No.",
                    temperature=0
                )
                answer1 = res1.data.strip().lower()
                print("Answer1:", answer1)
        
                if "yes" in answer1:
                    yes_count += 1
        
                print("=== Does the text 'got milk?' appear in the video? ===")
                res2 = client.analyze(
                    video_id=video_id,
                    prompt="Does the text got milk? appear in the video? Answer Yes or No.",
                    temperature=0
                )
                answer2 = res2.data.strip().lower()
                print("Answer2:", answer2)
        
                if "yes" in answer2:
                    yes_count += 1
        
                print("=== Are the words 'milk' or the phrase 'got milk' spoken in the audio? ===")
                res3 = client.analyze(
                    video_id=video_id,
                    prompt="Are the words 'milk' or the phrase 'got milk' spoken in the audio? Answer Yes or No.",
                    temperature=0
                )
                answer3 = res3.data.strip().lower()
                print("Answer3:", answer3)
        
                if "yes" in answer3:
                    yes_count += 1
        
                # Final Decision
                if yes_count >= 2:
                    print("At least 2/3 answers are YES")
                    table = dynamodb.Table("is_part_of_campaign")
        
                    # Insert a brand new document
                    table.put_item(
                        Item={
                            "video_id": video_id,
                            "s3_path": record["dynamodb"]["NewImage"]["s3_path"]["S"],
                            "bucket": record["dynamodb"]["NewImage"]["bucket"]["S"],
                            "metadata": record["dynamodb"]["NewImage"]["metadata"]["M"],
                            "index_id": record["dynamodb"]["NewImage"]["index_id"]["S"],
                            "is_part_of_campaign": True,
                            "analyze_yes_count": yes_count,
                            "s3_prefix": record["dynamodb"]["NewImage"]["s3_prefix"]["S"]
                        }
                    )
                    print(f"Inserted into is_part_of_campaign for video_id={video_id}")
        
                else:
                    print("Less than 2/3 answers are YES")
            
            # Return lambda response
            return {
              'statusCode': 200,
                'body': json.dumps('Lambda execution complete')
            }          
      Timeout: 300
      MemorySize: 1024
      EphemeralStorage: 
        Size: 1024
      Layers:
        - !Ref TwelveLabLambdaLayer
      Environment:
        Variables:
          API_KEY: !Ref TwelveLabAPIKey

  DynamoDBTriggerIsPartOfCampaign:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt SimpleChecksIndexing.StreamArn
      FunctionName: !Ref IsPartOfCampaign
      StartingPosition: LATEST # Or TRIM_HORIZON
      BatchSize: 1 # Number of records to process in a batch

  #
  # Lambda Function #3 - milk_mob
  #
  MilkMob:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: 'milk_mob' 
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.14
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          from twelvelabs import TwelveLabs
          from twelvelabs.embed import TasksStatusResponse
          
          def lambda_handler(event, context):
            dynamodb = boto3.resource("dynamodb")
            s3 = boto3.client("s3")
            s3vectors = boto3.client("s3vectors")
        
            print("=== FULL DynamoDB EVENT ===")
            print(json.dumps(event))
        
            client = TwelveLabs(api_key=os.environ["API_KEY"])
        
            for record in event.get("Records", []):
        
                # Skip anything that is NOT an INSERT
                if record["eventName"] != "INSERT":
                    print(f"Skipping event {record['eventName']}")
                    continue
        
                video_id = record["dynamodb"]["NewImage"]["video_id"]["S"]
        
                print("Processing INSERT for video_id:", video_id)
                
                print("=== Title, Topics, Hashtags ===")
                
                res1 = client.gist(
                    video_id=video_id,
                    types=["title", "topic", "hashtag"]
                )
        
                title = res1.title
                topics = res1.topics
                hashtags = res1.hashtags
        
                print("Title: ", title)
                print("Topic: ".join(topics))
                print("Hashtag: ".join(hashtags))
        
                # Insert into DynamoDB
                table = dynamodb.Table("milk_mob")
        
                table.put_item(
                    Item={
                        "s3_path": record["dynamodb"]["NewImage"]["s3_path"]["S"],
                        "video_id": video_id,
                        "Title": title,
                        "Topics": topics,
                        "Hashtag": hashtags
                    }
                )
                print(f"Inserted into milk_mob for video_id={video_id}")
        
                print("=== GET S3 PRESIGNED URL ===")
                # Generate 15-minute presigned URL
                url = s3.generate_presigned_url(
                    ClientMethod="get_object",
                    Params={"Bucket": record["dynamodb"]["NewImage"]["bucket"]["S"], "Key": record["dynamodb"]["NewImage"]["s3_prefix"]["S"]},
                    ExpiresIn=900  # 900 seconds = 15 minutes
                )
        
                print("Generated Presigned URL:")
                print(url)
        
                print("=== GET Embeding ===")     
                task = client.embed.tasks.create(
                    model_name="marengo3.0",
                    video_embedding_scope=["video", "clip"],
                    video_url=url
                )
                print(f"Created video embedding task: id={task.id}")
        
                def on_task_update(t: TasksStatusResponse):
                    print(f"Status={t.status}")
        
                status = client.embed.tasks.wait_for_done(
                    task_id=task.id,
                    sleep_interval=5,
                    callback=on_task_update
                )    
                print(f"Embedding done: {status.status}")
        
                result = client.embed.tasks.retrieve(
                    task_id=task.id,
                    embedding_option=["visual", "audio", "transcription"]
                )
                #print("Embedding retrieve result:", result)
        
                visual_video_embedding = None
                for seg in result.video_embedding.segments:
                    if seg.embedding_option == "visual" and seg.embedding_scope == "video":
                        visual_video_embedding = seg.float_
                        break
                print("Embedding dim:", len(visual_video_embedding))
                print(visual_video_embedding)
                
                print("=== INSERT into S3 Table ===")
                response = s3vectors.put_vectors(
                    vectorBucketName="got-milk",
                    indexName="visual-video",
                    vectors=[
                        {
                            "key": record["dynamodb"]["NewImage"]["s3_prefix"]["S"],
                            "data": {
                                "float32": visual_video_embedding
                            }
                        }
                    ]
                )
        
                print("Upload complete:")
                print(json.dumps(response))
            
            # Return lambda response
            return {
              'statusCode': 200,
                'body': json.dumps('Lambda execution complete')
            }          
      Timeout: 300
      MemorySize: 1024
      EphemeralStorage: 
        Size: 1024
      Layers:
        - !Ref TwelveLabLambdaLayer
      Environment:
        Variables:
          API_KEY: !Ref TwelveLabAPIKey

  DynamoDBTriggerMilkMob:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt IsPartofCampaign.StreamArn
      FunctionName: !Ref MilkMob
      StartingPosition: LATEST # Or TRIM_HORIZON
      BatchSize: 1 # Number of records to process in a batch
